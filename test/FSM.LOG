KCPSM3 Assembler log file for program 'fsm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
06Jul2012-11:14:24

 Addr Code

 000                      ;string matching example
 000                      ; Match data table
 000                      CONSTANT TableAddressLow_port, 04
 000                      CONSTANT TableAddressHigh_port, 05
 000                      CONSTANT TableRead_port, 04
 000                      ; Network data table
 000                      CONSTANT NetworkAddressLow_port, 06
 000                      CONSTANT NetworkAddressHigh_port, 07
 000                      CONSTANT NetworkRead_port, 06
 000                      ; match output port
 000                      ; can output to this port to indicate a string match
 000                      ; also use for debugging.  e.g. output F0 or F1 or F2 etc to
 000                      ; show where we are in the assembler code
 000                      CONSTANT Match_port, 08
 000                      ; registers to load a row of data from the match data table
 000                      NAMEREG sA, type
 000                      NAMEREG sB, char
 000                      NAMEREG sC, nshi
 000                      NAMEREG sD, nslo
 000                      ; register to hold the current byte from the network
 000                      NAMEREG sE, networkInput
 000                      ; temporary register to put things in
 000                      NAMEREG sF, temp
 000                      ; values for the 'type' entry in a row of match data
 000                      CONSTANT TYPE_MATCH, 00
 000                      CONSTANT TYPE_TEST, 01
 000                      CONSTANT TYPE_GOTODROP, 02
 000                      CONSTANT TYPE_GOTORETRY, 03
 000               start: ; initialise the hardware
 000                      ; get value 00 into a register
 000  00F00               LOAD temp[sF], 00
 001                      ; set hardware counter for the match data table to 0000
 001  2CF04               OUTPUT temp[sF], TableAddressLow_port[04]
 002  2CF05               OUTPUT temp[sF], TableAddressHigh_port[05]
 003                      ; set hardware counter for the network data table to 0000
 003  2CF06               OUTPUT temp[sF], NetworkAddressLow_port[06]
 004  2CF07               OUTPUT temp[sF], NetworkAddressHigh_port[07]
 005                      ;
 005                      ; the main loop
 005                      ;
 005                 top: ; get next byte from network into the register 'networkInput'
 005  04E06               INPUT networkInput[sE], NetworkRead_port[06]
 006                loop: ; get next row from the match data table
 006                      ; reads a row of 4 bytes at the current match table address
 006                      ; and leaves the table address register pointing to the next row
 006                      ; the row is now stored in registers: type, char, nshi, nslo
 006                      ; we can now access this data for the current row directly via the registers
 006  04A04               INPUT type[sA], TableRead_port[04]
 007  04B04               INPUT char[sB], TableRead_port[04]
 008  04C04               INPUT nshi[sC], TableRead_port[04]
 009  04D04               INPUT nslo[sD], TableRead_port[04]
 00A                      ;OUTPUT networkInput, Match_port
 00A                      ; If the type is 0 (test match)
 00A  14A00               COMPARE type[sA], 00
 00B                      ; Call testmatch
 00B  31016               CALL Z, testmatch[016]
 00C                      ; If the type is 1 (compare character)
 00C  14A01               COMPARE type[sA], 01
 00D  3101A               CALL Z, comparechar[01A]
 00E  14A02               COMPARE type[sA], 02
 00F  3101E               CALL Z, drop[01E]
 010  14A03               COMPARE type[sA], 03
 011  31020               CALL Z, retry[020]
 012                      ; Some notes
 012                      ;
 012                      ; we now have the current byte from the network in 'networkInput'
 012                      ; and the current row from the match data table in four registers
 012                      ; we can check the value in the register 'type' to work out what action
 012                      ; to take.  See notes in original 'table.txt' file, which are:
 012                      ;
 012                      ; * four different types of row, all 4 bytes long
 012                      ; *
 012                      ; * 0, 0, 0, Match, // first row of a state, which may indicate a string match
 012                      ; * 1, test, next1, next0, // compare current character with 'test' and if equal goto next1:next0
 012                      ; * 2, 0, next1, next0, // goto next1:next0 and drop current character
 012                      ; * 3, 0, next1, next0, // goto next1:next0 and retry with current character
 012                      ;
 012                      ; for row type 1 we can compare the registers 'char' and 'networkInput'
 012                      ;
 012                      ; we can 'goto next1:next2' by calling subroutine: 'newaddress'. This will update
 012                      ; the current value in the hardware counter with the address in registers: nshi and nslo
 012                      ;
 012                      ; we can indicate a match by doing an OUPUT to port 'Match_port'
 012                      ;
 012                      ; after we have performed any action, then:
 012                      ;     in case of row type 2 and for row type 1 if the characters match, then
 012                      ;     we need to jump back to label 'top' to get a new byte from the network
 012                      ;
 012                      ; otherwise we need to jump back to label 'loop' to get the next row from
 012                      ; from the match data tabel to process
 012  34006               JUMP loop[006]
 013          newAddress: ; subroutine to update the hardware counter for the match data table
 013                      ; this is then set to the values that are currently in the registers nshi:nslo
 013                      ; and allows us to 'jump' to the address shown in the current row
 013  2CD04               OUTPUT nslo[sD], TableAddressLow_port[04]
 014  2CC05               OUTPUT nshi[sC], TableAddressHigh_port[05]
 015  2A000               RETURN
 016           testmatch: 
 016                      ; If there is no match
 016  14D00               COMPARE nslo[sD], 00
 017                      ; Return
 017  2B000               RETURN Z
 018                      ; Else, output word's "id" to match port
 018  2CD08               OUTPUT nslo[sD], Match_port[08]
 019                      ; Get a new byte from the network
 019  34006               JUMP loop[006]
 01A         comparechar: 
 01A                      ; Compare current char with packet char
 01A  15BE0               COMPARE char[sB], networkInput[sE]
 01B                      ; Return if different
 01B  2B400               RETURN NZ
 01C                      ; Else, go to new address
 01C  30013               CALL newAddress[013]
 01D                      ; Fetch new char
 01D  34005               JUMP top[005]
 01E                drop: 
 01E  30013               CALL newAddress[013]
 01F  34005               JUMP top[005]
 020               retry: 
 020                      ; Go to new address
 020  30013               CALL newAddress[013]
 021                      ; Continue with the same char
 021  34006               JUMP loop[006]
