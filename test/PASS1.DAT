      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;string matching example
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Match data table
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableAddressLow_port
   OPERAND2-04
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableAddressHigh_port
   OPERAND2-05
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableRead_port
   OPERAND2-04
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Network data table
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkAddressLow_port
   OPERAND2-06
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkAddressHigh_port
   OPERAND2-07
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkRead_port
   OPERAND2-06
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; match output port
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; can output to this port to indicate a string match
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; also use for debugging.  e.g. output F0 or F1 or F2 etc to
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; show where we are in the assembler code
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-Match_port
   OPERAND2-08
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; registers to load a row of data from the match data table
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sA
   OPERAND2-type
    COMMENT-
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sB
   OPERAND2-char
    COMMENT-
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sC
   OPERAND2-nshi
    COMMENT-
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sD
   OPERAND2-nslo
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; register to hold the current byte from the network
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sE
   OPERAND2-networkInput
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; temporary register to put things in
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sF
   OPERAND2-temp
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; values for the 'type' entry in a row of match data
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_MATCH
   OPERAND2-00
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_TEST
   OPERAND2-01
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_GOTODROP
   OPERAND2-02
    COMMENT-
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_GOTORETRY
   OPERAND2-03
    COMMENT-
      LABEL-start
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; initialise the hardware
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get value 00 into a register
      LABEL-
INSTRUCTION-LOAD
   OPERAND1-temp
   OPERAND2-00
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; set hardware counter for the match data table to 0000
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-TableAddressLow_port
    COMMENT-
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-TableAddressHigh_port
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; set hardware counter for the network data table to 0000
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-NetworkAddressLow_port
    COMMENT-
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-NetworkAddressHigh_port
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the main loop
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-top
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get next byte from network into the register 'networkInput'
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-networkInput
   OPERAND2-NetworkRead_port
    COMMENT-
      LABEL-loop
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get next row from the match data table
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; reads a row of 4 bytes at the current match table address
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and leaves the table address register pointing to the next row
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the row is now stored in registers: type, char, nshi, nslo
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can now access this data for the current row directly via the registers
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-type
   OPERAND2-TableRead_port
    COMMENT-
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-char
   OPERAND2-TableRead_port
    COMMENT-
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-nshi
   OPERAND2-TableRead_port
    COMMENT-
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-nslo
   OPERAND2-TableRead_port
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;OUTPUT networkInput, Match_port
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If the type is 0 (test match)
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-00
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Call testmatch
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-testmatch
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If the type is 1 (compare character)
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-01
    COMMENT-
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-comparechar
    COMMENT-
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-02
    COMMENT-
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-drop
    COMMENT-
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-03
    COMMENT-
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-retry
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Some notes
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we now have the current byte from the network in 'networkInput'
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and the current row from the match data table in four registers
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can check the value in the register 'type' to work out what action
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; to take.  See notes in original 'table.txt' file, which are:
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * four different types of row, all 4 bytes long
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; *
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 0, 0, 0, Match, // first row of a state, which may indicate a string match
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 1, test, next1, next0, // compare current character with 'test' and if equal goto next1:next0
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 2, 0, next1, next0, // goto next1:next0 and drop current character
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 3, 0, next1, next0, // goto next1:next0 and retry with current character
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; for row type 1 we can compare the registers 'char' and 'networkInput'
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can 'goto next1:next2' by calling subroutine: 'newaddress'. This will update
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the current value in the hardware counter with the address in registers: nshi and nslo
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can indicate a match by doing an OUPUT to port 'Match_port'
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; after we have performed any action, then:
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;     in case of row type 2 and for row type 1 if the characters match, then
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;     we need to jump back to label 'top' to get a new byte from the network
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; otherwise we need to jump back to label 'loop' to get the next row from
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; from the match data tabel to process
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
      LABEL-newAddress
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; subroutine to update the hardware counter for the match data table
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; this is then set to the values that are currently in the registers nshi:nslo
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and allows us to 'jump' to the address shown in the current row
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nslo
   OPERAND2-TableAddressLow_port
    COMMENT-
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nshi
   OPERAND2-TableAddressHigh_port
    COMMENT-
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-
   OPERAND2-
    COMMENT-
      LABEL-testmatch
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If there is no match
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-nslo
   OPERAND2-00
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Return
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-Z
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Else, output word's "id" to match port
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nslo
   OPERAND2-Match_port
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Get a new byte from the network
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
      LABEL-comparechar
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Compare current char with packet char
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-char
   OPERAND2-networkInput
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Return if different
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-NZ
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Else, go to new address
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Fetch new char
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-top
   OPERAND2-
    COMMENT-
      LABEL-drop
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-top
   OPERAND2-
    COMMENT-
      LABEL-retry
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Go to new address
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Continue with the same char
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
