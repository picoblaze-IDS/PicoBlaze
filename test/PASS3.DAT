    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;string matching example
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Match data table
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableAddressLow_port
   OPERAND2-04
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableAddressHigh_port
   OPERAND2-05
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TableRead_port
   OPERAND2-04
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Network data table
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkAddressLow_port
   OPERAND2-06
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkAddressHigh_port
   OPERAND2-07
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-NetworkRead_port
   OPERAND2-06
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; match output port
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; can output to this port to indicate a string match
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; also use for debugging.  e.g. output F0 or F1 or F2 etc to
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; show where we are in the assembler code
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-Match_port
   OPERAND2-08
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; registers to load a row of data from the match data table
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sA
   OPERAND2-type
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sB
   OPERAND2-char
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sC
   OPERAND2-nshi
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sD
   OPERAND2-nslo
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; register to hold the current byte from the network
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sE
   OPERAND2-networkInput
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; temporary register to put things in
    ADDRESS-000
      LABEL-
INSTRUCTION-NAMEREG
   OPERAND1-sF
   OPERAND2-temp
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; values for the 'type' entry in a row of match data
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_MATCH
   OPERAND2-00
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_TEST
   OPERAND2-01
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_GOTODROP
   OPERAND2-02
    COMMENT-
    ADDRESS-000
      LABEL-
INSTRUCTION-CONSTANT
   OPERAND1-TYPE_GOTORETRY
   OPERAND2-03
    COMMENT-
    ADDRESS-000
      LABEL-start
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; initialise the hardware
    ADDRESS-000
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get value 00 into a register
    ADDRESS-000
      LABEL-
INSTRUCTION-LOAD
   OPERAND1-temp
   OPERAND2-00
    COMMENT-
    ADDRESS-001
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; set hardware counter for the match data table to 0000
    ADDRESS-001
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-TableAddressLow_port
    COMMENT-
    ADDRESS-002
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-TableAddressHigh_port
    COMMENT-
    ADDRESS-003
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; set hardware counter for the network data table to 0000
    ADDRESS-003
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-NetworkAddressLow_port
    COMMENT-
    ADDRESS-004
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-temp
   OPERAND2-NetworkAddressHigh_port
    COMMENT-
    ADDRESS-005
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-005
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the main loop
    ADDRESS-005
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-005
      LABEL-top
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get next byte from network into the register 'networkInput'
    ADDRESS-005
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-networkInput
   OPERAND2-NetworkRead_port
    COMMENT-
    ADDRESS-006
      LABEL-loop
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; get next row from the match data table
    ADDRESS-006
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; reads a row of 4 bytes at the current match table address
    ADDRESS-006
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and leaves the table address register pointing to the next row
    ADDRESS-006
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the row is now stored in registers: type, char, nshi, nslo
    ADDRESS-006
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can now access this data for the current row directly via the registers
    ADDRESS-006
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-type
   OPERAND2-TableRead_port
    COMMENT-
    ADDRESS-007
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-char
   OPERAND2-TableRead_port
    COMMENT-
    ADDRESS-008
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-nshi
   OPERAND2-TableRead_port
    COMMENT-
    ADDRESS-009
      LABEL-
INSTRUCTION-INPUT
   OPERAND1-nslo
   OPERAND2-TableRead_port
    COMMENT-
    ADDRESS-00A
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;OUTPUT networkInput, Match_port
    ADDRESS-00A
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If the type is 0 (test match)
    ADDRESS-00A
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-00
    COMMENT-
    ADDRESS-00B
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Call testmatch
    ADDRESS-00B
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-testmatch
    COMMENT-
    ADDRESS-00C
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If the type is 1 (compare character)
    ADDRESS-00C
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-01
    COMMENT-
    ADDRESS-00D
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-comparechar
    COMMENT-
    ADDRESS-00E
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-02
    COMMENT-
    ADDRESS-00F
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-drop
    COMMENT-
    ADDRESS-010
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-type
   OPERAND2-03
    COMMENT-
    ADDRESS-011
      LABEL-
INSTRUCTION-CALL
   OPERAND1-Z
   OPERAND2-retry
    COMMENT-
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Some notes
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we now have the current byte from the network in 'networkInput'
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and the current row from the match data table in four registers
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can check the value in the register 'type' to work out what action
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; to take.  See notes in original 'table.txt' file, which are:
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * four different types of row, all 4 bytes long
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; *
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 0, 0, 0, Match, // first row of a state, which may indicate a string match
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 1, test, next1, next0, // compare current character with 'test' and if equal goto next1:next0
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 2, 0, next1, next0, // goto next1:next0 and drop current character
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; * 3, 0, next1, next0, // goto next1:next0 and retry with current character
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; for row type 1 we can compare the registers 'char' and 'networkInput'
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can 'goto next1:next2' by calling subroutine: 'newaddress'. This will update
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; the current value in the hardware counter with the address in registers: nshi and nslo
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; we can indicate a match by doing an OUPUT to port 'Match_port'
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; after we have performed any action, then:
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;     in case of row type 2 and for row type 1 if the characters match, then
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;     we need to jump back to label 'top' to get a new byte from the network
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-;
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; otherwise we need to jump back to label 'loop' to get the next row from
    ADDRESS-012
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; from the match data tabel to process
    ADDRESS-012
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
    ADDRESS-013
      LABEL-newAddress
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; subroutine to update the hardware counter for the match data table
    ADDRESS-013
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; this is then set to the values that are currently in the registers nshi:nslo
    ADDRESS-013
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; and allows us to 'jump' to the address shown in the current row
    ADDRESS-013
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nslo
   OPERAND2-TableAddressLow_port
    COMMENT-
    ADDRESS-014
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nshi
   OPERAND2-TableAddressHigh_port
    COMMENT-
    ADDRESS-015
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-
   OPERAND2-
    COMMENT-
    ADDRESS-016
      LABEL-testmatch
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
    ADDRESS-016
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; If there is no match
    ADDRESS-016
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-nslo
   OPERAND2-00
    COMMENT-
    ADDRESS-017
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Return
    ADDRESS-017
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-Z
   OPERAND2-
    COMMENT-
    ADDRESS-018
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Else, output word's "id" to match port
    ADDRESS-018
      LABEL-
INSTRUCTION-OUTPUT
   OPERAND1-nslo
   OPERAND2-Match_port
    COMMENT-
    ADDRESS-019
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Get a new byte from the network
    ADDRESS-019
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
    ADDRESS-01A
      LABEL-comparechar
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
    ADDRESS-01A
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Compare current char with packet char
    ADDRESS-01A
      LABEL-
INSTRUCTION-COMPARE
   OPERAND1-char
   OPERAND2-networkInput
    COMMENT-
    ADDRESS-01B
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Return if different
    ADDRESS-01B
      LABEL-
INSTRUCTION-RETURN
   OPERAND1-NZ
   OPERAND2-
    COMMENT-
    ADDRESS-01C
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Else, go to new address
    ADDRESS-01C
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
    ADDRESS-01D
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Fetch new char
    ADDRESS-01D
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-top
   OPERAND2-
    COMMENT-
    ADDRESS-01E
      LABEL-drop
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
    ADDRESS-01E
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
    ADDRESS-01F
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-top
   OPERAND2-
    COMMENT-
    ADDRESS-020
      LABEL-retry
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-
    ADDRESS-020
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Go to new address
    ADDRESS-020
      LABEL-
INSTRUCTION-CALL
   OPERAND1-newAddress
   OPERAND2-
    COMMENT-
    ADDRESS-021
      LABEL-
INSTRUCTION-
   OPERAND1-
   OPERAND2-
    COMMENT-; Continue with the same char
    ADDRESS-021
      LABEL-
INSTRUCTION-JUMP
   OPERAND1-loop
   OPERAND2-
    COMMENT-
